const MASK = 2n**64n-1n;

const count_if_pos = (bi)=> { 
    let cnt =0;
    while(bi) {
       bi = bi>>64n;
       ++cnt; 
    } 
    return(cnt)
}

const data_byte_length_if_pos = (bi)=> 8*count_if_pos(bi);


const _get_head =  (bi)=> {
    let sign=0;
    if(bi>=0n) {

    } else {
       sign = 1;
       bi   = -bi;
    }
    let blen      = data_byte_length_if_pos(bi);
    return([sign,blen,bi])
}

const get_encd_head  = (bi)=> {
    let [sign,blen,pos_bi] = _get_head(bi);
    let head               = (sign | (blen<<1));
    return(head)
}

const decd_encd_head = (head) => {
    let sign = head & 1;
    let blen = head >> 1;
    return({sign,data_blen:blen})
}


const gen_body_if_pos = function * (bi) {
    while(bi) {
        yield(bi & MASK);
        bi = bi>>64n;
    } 
}



const count               = (bi)=>(bi>=0n)?count_if_pos(bi):count_if_pos(-bi);
const data_byte_length    = (bi)=>(bi>=0n)?data_byte_length_if_pos(bi):data_byte_length_if_pos(-bi);

const gen_body = function * (bi) {
    bi = (bi>=0)?bi:(-bi);
    while(bi) {
        yield(bi & MASK);
        bi = bi>>64n;
    }
}

const use_with_get_var_int = (orig_bi,u8a,offset=0,GetVarInt) => {
    let [sign,blen,bi] = _get_head(orig_bi);
    let encd_head = (sign | blen);
    ////head
    let head_offset = offset;
    let smi_arr       = GetVarInt(encd_head);
    for(let i=0;i<smi_arr.length;++i) {u8a[offset+i] = smi_arr[i];}
    ////body
    offset = offset + smi_arr.length;
    let body_offset = offset;
    let dv        = new DataView(u8a.buffer);
    while(bi) {
        dv.setBigUint64(bi & MASK,offset,_t);
        offset = offset+8;
        bi = bi>>64n;
    }
    return({sign,data:u8a,head_offset,body_offset,curr_offset:offset})
}

module.exports = {
    MASK,
    count_if_pos,data_byte_length_if_pos,
    count,data_byte_length,
    _get_head,get_encd_head,
    decd_encd_head,
    gen_body_if_pos, gen_body,
    ////
    use_with_get_var_int,
}
