
const creat = (o,max_byt_sz)=>{
   if(typeof(o) === 'number') {
       if(max_byt_sz !== undefined) {
	  return(new ArrayBuffer(o,{maxByteLength:max_byt_sz}));
       } else {
	   return(new ArrayBuffer(o));    
       }
   } else if(o instanceof ArrayBuffer){
       var ab;
       if(o.resizable) {
	    ab = new ArrayBuffer(o.byteLength,{maxByteLength:o.maxByteLength})
       } else {
            ab = new ArrayBuffer(o.byteLength);
       }
       var old_u8a = new Uint8Array(o);
       (new Uint8Array(ab)).set(old_u8a);
       return(ab);
   } else if(o.buffer && (o.buffer instanceof ArrayBuffer)){
       var si    = o.byteOffset;
       var ei    = si + o.byteLength;
       if(max_byt_sz !== undefined) {
           return(o.buffer.slice(si,ei));
       } else {
	   var ab = new ArrayBuffer(ei-si,{maxByteLength:max_byt_sz});
	   var old_u8a = new Uint8Array(o.buffer).subarray(si,ei);
           (new Uint8Array(ab)).set(old_u8a);
	   return(ab);    
       }
   } else {
       var cnt = o.length;
       var ab;
       if(o.resizable) {
            ab = new ArrayBuffer(cnt,{maxByteLength:o.maxByteLength})
       } else {
            ab = new ArrayBuffer(cnt);
       }
       var u8a = new Uint8Array(ab);
       for(var i=0;i<cnt;++i){
	   u8a[i] = o[i]; 
       }
       return(ab);
   } 
}

const to_str = require("nv-stringify-ab").ab;


const _cp = (src_ab,src_offset,cp_size,dst_ab,dst_offset) => {
    let src_u8a =  new Uint8Array(src_ab,src_offset,cp_size);
    let dst_u8a =  new Uint8Array(dst_ab);
    dst_u8a.set(src_u8a,dst_offset);
    return(dst_ab)
}


const cp = (src_ab,dst_ab,src_offset,cp_size,dst_offset) => {
    src_offset = src_offset??0;
    cp_size = cp_size??src_ab.byteLength;
    dst_offset = dst_offset??0;
    return(_cp(src_ab,src_offset,cp_size,dst_ab,dst_offset));
}

const cp_from_src_start       = (src_ab,dst_ab,cp_size,dst_offset=0) =>  cp(src_ab,dst_ab,0,cp_size,dst_offset); 
const cp_all_if_dst_is_enough = (src_ab,dst_ab,        dst_offset=0) => _cp(src_ab,0,src_ab.byteLength,dst_ab,dst_offset);

const cp_all_if_same_blen     = (src_ab,dst_ab)                      => _cp(src_ab,0,src_ab.byteLength,dst_ab,0);


const dupe_u8a_and_push = (u8a,...args) => {
      let arglen = args.length;
      let nu8a = new Uint8Array(u8a.length+arglen);
      for(let i=0;i<arglen;++i) {nu8a[u8a.length+i] = args[i];}
      nu8a.set(u8a);
      return(u8a)
}

const dupe_u8a_and_unshift = (u8a,...args) => {
     let arglen = args.length;
     let nu8a = new Uint8Array(u8a.length+arglen);
     for(let i=0;i<arglen;++i) {nu8a[i] = args[i];}
     nu8a.set(u8a,arglen);
     return(u8a)
}

const dupe_and_push    = (ab,...args) => dupe_u8a_and_push(new Uint8Array(ab),...args).buffer;
const dupe_and_unshift = (ab,...args) => dupe_u8a_and_unshift(new Uint8Array(ab),...args).buffer;


module.exports = {
    creat, to_str,
    _cp, cp,
    cp_from_src_start,	
    cp_all_if_dst_is_enough,	
    cp_all_if_same_blen,
    ////
    dupe_u8a_and_push,dupe_u8a_and_unshift,
    dupe_and_push,dupe_and_unshift,
}
