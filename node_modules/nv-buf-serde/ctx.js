const _A = Array;

const {_u,_n,_t,_f} = require("nv-facutil-untf");

const {creat_nid} = require("./zero-nid");

class WIdMap extends WeakMap {
    #id = creat_nid();
    ////
    FindOrInsert(o) {
       let idx = this.get(o);
       if(idx === _u) {
           let nidx = this.#id.next();
           this.set(o,nidx);
           return([_f,nidx])       // not obj-ref
       } else {
           return([_t,idx])        // is-obj-ref
       }
    }
}

const creat_widmap = () => new WIdMap();

class Wctx {
   //zone                             = _u;                                 //not-support
   idmap                           = new WIdMap();
   //array_buffer_transfer_map        = _u;                                 //not-support
   //delegate                         = _u;                                 //not-support 
   //shared_object_conveyor           = _u;                                 //not-support
}

const creat_wctx = ()=> new Wctx();


class RIdMap extends _A {
     HasObjectWithID(id)   {return(this[id]!==_u)}
     GetObjectWithID(id)   {return(this[id])     }
     AddObjectWithID(o)    {this.push(o)}
     get nid_()            {return(this.length)}
}

const creat_ridmap = ()=>new RIdMap();

/* 
// for feature using 

const ENTRY_TYPED = {
     unknown:0,
     ae:1,
     dpair:2,
     dk:3,
     dp:4,
     ste:5,
     mpair:6,
     mpk:7,
     mpv:8
}

class Entry {
    ref   = _u;
    type  = ENTRY_TYPED.unknown;
    pr    = _u;
    twin  = _u;
    constructor(ref,type,pr,twin) {
        this.ref  = ref;
        this.type = type;
        this.pr   = pr;
        this.twin = twin;
    }
}
class Rctx {
     idmap = new RIdMap();
     stack = []
     push(o,pr,type,twin) {
         let e = new Entry(o,pr,type,twin);
         this.stack.push(e)
     }
     get top_() {return(this[this.stack.length-1])}
}

const creat_rctx = ()=>new Rctx();
*/

module.exports = {
   creat_widmap, 
   creat_wctx,
   creat_ridmap, 
   creat_rctx   : creat_ridmap,
}
