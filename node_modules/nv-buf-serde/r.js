const {_u,_n,_t,_f} = require("nv-facutil-untf");
const {thrw_str}    = require("nv-facutil-thrw");
const _ab                = require("nv-facutil-ab");
const _zigzag            = require("nv-number-zigzag");
const _utf16             = require("nv-buf-jstr");
const _rgx_flag          = require("nv-regexp-flags");
const _misc              = require("./misc");
const {SerializationTag,ErrorTag,ArrayBufferViewIndexToCtor,CreatUnknown} = require("./const");
const { creat_rctx } = require("./ctx");

const ERRD = {
   must_be_str:"must_be_str"
}


const ReadVarintLoopIfLshiftWork = (u8a,si,ctx) => {
    let old_si           = si;
    let v                = 0;
    let shift            = 0;
    let has_another_byte = _f;
    do {
        let byte         = u8a[si];
        has_another_byte = byte & 0x80;
        if(shift < 32) {
            v |= (byte & 0x7F) << shift;
            shift = shift +7;
        } else {
            break;
        }
        ++si;
    } while(has_another_byte);
    return([v,si-old_si,si])
}

const ReadVarintLoop = (u8a,si,ctx) => {
    let old_si           = si;
    let v                = 0n;
    let shift            = 0n;
    let has_another_byte = _f;
    do {
        let byte         = BigInt(u8a[si]);
        has_another_byte = byte & 0x80n;
        if(shift < 32n) {
            v |= (byte & 0x7Fn) << shift;
            shift = shift +7n;
        } else {
            break;
        }
        ++si;
    } while(has_another_byte);
    return([Number(v),si-old_si,si])
}

const ReadVarint = ReadVarintLoop;  // in js-layer no need unroll

const ReadHeader = (u8a,si,ctx) => {
    let old_si = si;
    ++si;                        // tag
    let kLatestVersion = u8a[si];
    ++si;
    return([kLatestVersion,si-old_si,si])
}

const ReadTag = (u8a,si,ctx) => {
    let old_si = si;
    let tag;	
    do {
        tag = u8a[si];
        ++si;
    } while(tag === SerializationTag.kPadding);
    return([tag,si-old_si,si])
}

const ReadZigZag = (u8a,si,ctx,decode=_zigzag.decd) => {
    let old_si = si;
    let a3 = ReadVarint(u8a,si,ctx);
    let unsigned = a3[0];
    si = a3[2];
    let v = decode(unsigned);
    return([v,si-old_si,si])	
}


const ReadDouble = (u8a,si,ctx) => {
    let dv  = new DataView(u8a.buffer);
    let v   = dv.getFloat64(si,_t); 
    si = si+8;
    return([v,8,si])
}

const ReadRawBytes = (u8a,si,sz,ctx) => {
   let old_si = si; 
   let nu8a = new Uint8Array(u8a.buffer,si,sz);
   si = si + sz;
   return([nu8a,sz,si])  
}

const ReadByte  = (u8a,si,ctx) => {
   ++si; 
   return([u8a[i],1,si]) 
}

const ReadUint32 = (u8a,si,ctx) => ReadVarint(u8a,si,ctx);

const BI_MUL = 2n**64n;

const ReadBigInt = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadVarint(u8a,si,ctx);
    let bitfield = a3[0];
    let sign     = bitfield & 0x1;
    let byte_len = bitfield >> 1;
    si = a3[2];
    ////
    let data_si = si;
    a3 = ReadRawBytes(u8a,si,byte_len,ctx);
    let nu8a   = a3[0];
    let dv     = new DataView(nu8a.buffer);
    let bi  = 0n;
    let mul = 1n;
    let bi_len = byte_len /8;
    for(let i =0;i<bi_len;++i) {
        let nbi = dv.getBigUint64(data_si,_t);
        bi = bi + (nbi * mul);
        mul = mul * BI_MUL;
        data_si = data_si + 8;
    }
    if(sign === 1) { bi = -bi;} else {}
    si = a3[2];
    return([bi,si-old_si,si])
}

const ReadOneByteString = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadVarint(u8a,si,ctx);
    let blen = a3[0];
    si = a3[2];
    let s = _misc.Latin1U8aToStr(u8a,si,blen);
    si +=  blen;
    return([s,si-old_si,si])
}

const ReadTwoByteString = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadVarint(u8a,si,ctx);
    let blen = a3[0];
    si = a3[2];	
    let s = _misc.JstrU8aToStr(u8a,si,blen);
    si += blen;
    return([s,si-old_si,si])
}

const ReadUtf8String    = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadVarint(u8a,si,ctx);
    let blen = a3[0];
    si = a3[2];	
    let s = _misc.Utf8U8aToStr(u8a,si,blen);
    si += blen;
    return([s,si-old_si,si])
}



const ReadJSDate = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadDouble(u8a,si,ctx);
    let v  = a3[0];
    let dt = new Date(v);
    si = a3[2];
    ctx.AddObjectWithID(dt);
    return([dt,si-old_si,si])
}


const ReadJSPrimitiveWrapper = (u8a,si,tag,ctx) => {
     let old_si = si;
     let v;
     switch (tag) {
        case SerializationTag.kTrueObject:             {v = new Boolean(_t);break;}
        case SerializationTag.kFalseObject:            {v = new Boolean(_f);break;}
        case SerializationTag.kNumberObject:          {
            let a3 = ReadDouble(u8a,si,ctx);
            let num = a3[0];
            si = a3[2];
            v = new Number(num);
            break;
       }
       case SerializationTag.kStringObject: {
           let a3 = ReadString(u8a,si,ctx);
           let s = a3[0];
           si = a3[2];
           v = new String(s);
           break;
       }
       case SerializationTag.kBigIntObject: {
           let a3 = ReadBigInt(u8a,si,ctx);
           let bi = a3[0];
           si  = a3[2];
           // this is impossible in js-layer
           //v = new BigInt(bi);
           v = CreatFakeCantBeSered("BigInt",bi);
           break;
       }
       default: {}
  }
  ctx.AddObjectWithID(v);
  return([v,si-old_si,si])
}


const ReadJSError = (u8a,si,ctx) => {
      let old_si = si;
      let message   = _u;
      let stack     = _u;
      let cause     = _u;	
      let done      = _f;
      let ctor      = Error;
      ////
      while (!done) {
         let a3 = ReadVarint(u8a,si,ctx);
         let tag = a3[0];
         si = a3[2];  
         switch (tag) {
            case ErrorTag.kEvalErrorPrototype:         {ctor=EvalError;       break;}
            case ErrorTag.kRangeErrorPrototype:        {ctor=RangeError;      break;}
            case ErrorTag.kReferenceErrorPrototype:    {ctor=ReferenceError;  break;}
            case ErrorTag.kSyntaxErrorPrototype:       {ctor=SyntaxError;     break;} 
            case ErrorTag.kTypeErrorPrototype:         {ctor=TypeError;       break;}   
            case ErrorTag.kUriErrorPrototype:          {ctor=URIError;        break;}
            case ErrorTag.kMessage: {
                let a3 = ReadString(u8a,si,ctx);
                message = a3[0];
                si = a3[2];
                break;
            }
            case ErrorTag.kCause: {
                let a3 = ReadObject(u8a,si,ctx);
                cause = a3[0];
                si = a3[2];
                break;
           }
           case ErrorTag.kStack: {
                let a3 = ReadString(u8a,si,ctx);
                stack = a3[0];
                si = a3[2];
                break;
           }
           case ErrorTag.kEnd: {                          
                done = _t;
                break;
           }
           default:{}
        }
     }

     let err;
     if(cause) {
         err = new ctor(message,{cause})
     } else {
          err = new ctor(message)
     }
     err.stack = stack;
     ctx.AddObjectWithID(err);
     return([err,si-old_si,si])     
}

const ReadString = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadTag(u8a,si,ctx);
    let tag = a3[0];
    si = a3[2];
    switch(tag) {
        case SerializationTag.kOneByteString: {
            a3 = ReadOneByteString(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
        }
        case SerializationTag.kTwoByteString: {
            a3 = ReadTwoByteString(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
        }
	case SerializationTag.kUtf8String: {
            a3 = ReadUtf8String(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
        }
        default: {
	    thrw_str(ERRD.must_be_str)	
	}
    }
}


const ReadJSRegExp = (u8a,si,ctx) => {
     let old_si = si;
     let a3 = ReadString(u8a,si,ctx);
     let ptrn = a3[0];
     si = a3[2];
     a3 = ReadVarint(u8a,si,ctx);
     let flags = a3[0];
     flags = _rgx_flag.n2s(flags);
     si = a3[2];
     let rgx = new RegExp(ptrn,flags);
     ctx.AddObjectWithID(rgx);
     return([rgx,si-old_si,si])
}

const ReadJSSet = (u8a,si,ctx)=> {
     let old_si = si;
     let st     = new Set();
     ctx.AddObjectWithID(st);
     let sz = 0;
     while (_t) {
	  let rtrn_si = si;   
          let a3 = ReadTag(u8a,si,ctx);
          let tag = a3[0];
          si = a3[2];
          if (tag === SerializationTag.kEndJSSet) {
             break;
          } else {
	      si = rtrn_si;	  
              a3 = ReadObject(u8a,si,ctx);
              st.add(a3[0]);
              si = a3[2];
          }
          sz++;
     }
     let a3 = ReadVarint(u8a,si,ctx);    // in js-layer no-need to check
     si = a3[2];
     return([st,si-old_si,si,a3[0]/*just for check*/])  
}

const ReadJSMap = (u8a,si,ctx) => {
      let old_si = si;
      let mp     = new Map(); 
      ctx.AddObjectWithID(mp);
      let sz = 0; 
      while (_t) {
	  let rtrn_si = si;    
          let a3 = ReadTag(u8a,si,ctx);
          si = a3[2];
          let tag = a3[0];
          if (tag === SerializationTag.kEndJSMap) {
               break;
          } else {
	       si = rtrn_si;	  
               a3 = ReadObject(u8a,si,ctx);
               let mpk = a3[0];
               si = a3[2];
               a3 = ReadObject(u8a,si,ctx);
               let mpv = a3[0];
               si = a3[2];
               mp.set(mpk,mpv);
               sz = sz+2;
          }
      }
      let a3 = ReadVarint(u8a,si,ctx);
      si = a3[2];
      return([mp,si-old_si,si,a3[0]/*just for check*/])
}

const ReadHostObject = (u8a,si,ctx) => {
    let old_si = si;
    let a3 = ReadUint32(u8a,si,ctx);
    let typeIndex = a3[0];
    let ctor                 = ArrayBufferViewIndexToCtor[typeIndex];
    let BYTES_PER_ELEMENT    = ctor.BYTES_PER_ELEMENT ;

    si = a3[2];
    a3 = ReadUint32(u8a,si,ctx);


	let byteLength = a3[0];
    si = a3[2];
    let offset = si;
    a3 = ReadRawBytes(u8a,si,byteLength,ctx);
    
    
	let buf;
    if(si%BYTES_PER_ELEMENT === 0) { 	
	    buf = new ctor(a3[0].buffer,si,byteLength);
    } else {
        //need copy 
        buf = new ctor(a3[0].buffer.slice(si,si+byteLength)); 
    }
    si = a3[2];
    ctx.AddObjectWithID(buf);
    return([buf,si-old_si,si])
}

const ReadJSArrayBufferView = ReadHostObject;  //compatible to nodejs


const ReadJSArrayBuffer = (u8a,si,is_resizable,ctx) => {
     let old_si = si;
     let a3     = ReadVarint(u8a,si,ctx);
     let byte_length = a3[0];
     si = a3[2];
     let max_byte_length = byte_length;	
     let ab;
     if(is_resizable) {
	 let a3     = ReadVarint(u8a,si,ctx);
	 max_byte_length = a3[0];
	 ab = new ArrayBuffer(byte_length,{maxByteLength:max_byte_length});       
	 si = a3[2];    
         _ab._cp(u8a.buffer,si,byte_length,ab,0);	     
	 si = si + byte_length;
     } else {
	 let total_ab = u8a.buffer;
	 ab = total_ab.slice(si,si+byte_length);
         si = si + byte_length;
     }
     ctx.AddObjectWithID(ab);
     return([ab,si-old_si,si]) 
}

const ReadJSObjectProperties = (u8a,si,o,end_tag,is_ary,ctx) => {
             let old_si = si;
	     let num_properties = 0;
	     while(_t) {
		let rtrn_si = si;     
		let a3 = ReadTag(u8a,si,ctx);
		let tag = a3[0];
		si = a3[2];     
		if(tag !== end_tag) {
		    si = rtrn_si;	
		    a3 = ReadObject(u8a,si,ctx);
		    let key = a3[0];
		    si = a3[2];
		    a3 = ReadObject(u8a,si,ctx);
		    let val = a3[0];
		    si = a3[2];
		    o[key] = val;
		    ++num_properties;
		} else {
		    return([num_properties,si-old_si,si])
		}
	     }
}

const ReadJSObject = (u8a,si,ctx) => {
     let old_si = si;
     let o      = {};	
     ctx.AddObjectWithID(o);
     let a3 = ReadJSObjectProperties(u8a,si,o,SerializationTag.kEndJSObject,_f,ctx);	
     let num_properties = a3[0];
     si = a3[2]; 
     a3 = ReadVarint(u8a,si,ctx);  // expected_num_properties
     si = a3[2];
     return([o,si-old_si,si])	 // we dont verify expected_num_properties
}

const ReadJSArray = (u8a,si,begin_tag,ctx) => {
     let old_si = si;
     let a3 = ReadVarint(u8a,si,ctx);
     let length = a3[0];
     si = a3[2];	
     let a = []; 	
     ctx.AddObjectWithID(a);
     for(let i=0;i<length;++i) {
         a3 = ReadObject(u8a,si,ctx);
         a.push(a3[0]);	  
         si = a3[2];	  
     }
     /////
     let end_tag = (begin_tag === SerializationTag.kBeginDenseJSArray)?SerializationTag.kEndDenseJSArray:SerializationTag.kEndSparseJSArray;
     a3 = ReadJSObjectProperties(u8a,si,a,  end_tag,  _t,ctx);
     si = a3[2];
     a3 = ReadVarint(u8a,si,ctx);            // we dont check expected_num_properties  	
     si = a3[2];
     a3 = ReadVarint(u8a,si,ctx);            // we dont check  expected_length
     si = a3[2];	
     return([a,si-old_si,si])
}


const ReadObjectInternal = (u8a,si,ctx) => {
     let old_si = si;
     let a3 = ReadTag(u8a,si,ctx);
     let tag = a3[0];
     si = a3[2];	
     switch (tag) {
         case SerializationTag.kTheHole:           {return([_u,si-old_si,si]);}
         case SerializationTag.kUndefined:         {return([_u,si-old_si,si]);}
         case SerializationTag.kNull:              {return([_n,si-old_si,si]);}          
         case SerializationTag.kTrue:              {return([_t,si-old_si,si]);}
         case SerializationTag.kFalse:             {return([_f,si-old_si,si]);}
         case SerializationTag.kInt32:             {
	    a3 = ReadZigZag(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);		 
        }
        case SerializationTag.kUint32: {
	    a3 = ReadVarint(u8a,si,ctx); 	
	    si = a3[2];
	    return([a3[0],si-old_si,si]);	
        }
        case SerializationTag.kDouble: {
	    a3 = ReadDouble(u8a,si,ctx);
	    si = a3[2];
	    return([a3[0],si-old_si,si]);	
        }
        case SerializationTag.kBigInt: {
	    a3 = ReadBigInt(u8a,si,ctx);
	    si = a3[2];
	    return([a3[0],si-old_si,si]);	
	}
        case SerializationTag.kOneByteString: {
            a3 = ReadOneByteString(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kTwoByteString: {
            a3 = ReadTwoByteString(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kUtf8String: {
            a3 = ReadUtf8String(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
        }
        case SerializationTag.kBeginJSObject: {
	     a3 = ReadJSObject(u8a,si,ctx);
	     si = a3[2];
	     return([a3[0],si-old_si,si]);	
	}
        case SerializationTag.kBeginDenseJSArray :		     
        case SerializationTag.kBeginSparseJSArray: { // treat sparse same as dense
	     a3 = ReadJSArray(u8a,si,tag,ctx);
             si = a3[2];
             return([a3[0],si-old_si,si]);	    	
	}
        case SerializationTag.kDate: {
            a3 = ReadJSDate(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kBeginJSMap: {
            a3 = ReadJSMap(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
	}
	case SerializationTag.kBeginJSSet: {
            a3 = ReadJSSet(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kObjectReference: {
            a3 = ReadVarint(u8a,si,ctx);
            let id = a3[0];
            si = a3[2]; 
            let v = ctx.GetObjectWithID(id);
            return([v,si-old_si,si]);    
        }
	case SerializationTag.kRegExp:	         {
            a3 = ReadJSRegExp(u8a,si,ctx);
            si = a3[2];
            return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kSharedArrayBuffer:                 //treat sab as normal ab		     
	case SerializationTag.kArrayBuffer:         {
	     let is_resizable = _f; 	
             a3 = ReadJSArrayBuffer(u8a,si,is_resizable,ctx);
	     si = a3[2];
	     return([a3[0],si-old_si,si]);	
	}
	case SerializationTag.kResizableArrayBuffer: {
	     let is_resizable = _t;	
             a3 = ReadJSArrayBuffer(u8a,si,is_resizable,ctx);
             si = a3[2];
             return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kError:      {
             a3 = ReadJSError(u8a,si,ctx);
             si = a3[2];
             return([a3[0],si-old_si,si]);	    	
	}
	case SerializationTag.kArrayBufferView:		    //corresponding to nodejs 
        case SerializationTag.kHostObject: {
             a3 = ReadHostObject(u8a,si,ctx);
             si = a3[2];
             return([a3[0],si-old_si,si]);
	}
        case SerializationTag.kTrueObject:
        case SerializationTag.kFalseObject:
        case SerializationTag.kNumberObject:
        case SerializationTag.kBigIntObject:
        case SerializationTag.kStringObject:   {
	     a3 = ReadJSPrimitiveWrapper(u8a,si,tag,ctx);
	     si = a3[2];	
	     return([a3[0],si-old_si,si]);
	}
        default: {
	     console.log("why unknown",tag,si,u8a);	
             return([CreatUnknown(),si-old_si,si])	     	
        }
    }
}



const ReadObject = (u8a,si,ctx) => ReadObjectInternal(u8a,si,ctx);   //same as ReadObjectInternal , coz ArrayBufferView AS HostObject


const decd = (ab) => {
    let u8a = new Uint8Array(ab);	
    let ctx = creat_rctx();
    let si  = 0;
    let a3  = ReadHeader(u8a,si,ctx);
    si = a3[2];
    a3 = ReadObject(u8a,si,ctx);
    return(a3[0])	
}


module.exports = {
    ERRD,
    ////
    ReadVarintLoopIfLshiftWork,
    ReadVarint,
    ReadHeader,
    ReadTag,
    ReadZigZag,
    ReadDouble,
    ReadRawBytes,
    ReadByte,
    ReadUint32,
    ReadBigInt,BI_MUL,
    ReadOneByteString,
    ReadTwoByteString,
    ReadUtf8String,
    ReadJSDate,
    ReadString,
    ReadJSRegExp,
    ReadJSError,
    ReadJSSet,
    ReadJSMap,
    ReadHostObject,
    ReadJSArrayBufferView,
    ReadJSArrayBuffer,
    ReadJSObjectProperties,
    ReadObjectInternal,
    ReadObject,
    ReadJSObject,	
    ReadJSArray,
    ////
    decd
}
