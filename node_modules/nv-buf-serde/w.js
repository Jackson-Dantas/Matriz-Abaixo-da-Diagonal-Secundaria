const {_u,_n,_t,_f,is_untf} = require("nv-facutil-untf");

const _typis    = require("nv-facutil-typis");
const _istis    = require("nv-facutil-istis");
const {
    is_prms,
    is_g,
    is_iter
}  = require("nv-facutil-ppgflike-is");

const _zigzag   = require("nv-number-zigzag");
const _utf16    = require("nv-buf-jstr");
const _rgx_flag = require("nv-regexp-flags");
const _buf_bi   = require("nv-buf-bi");


const _misc     = require("./misc");
const {
    SerializationTag,
    ErrorTag,
    ArrayBufferViewTag,
    IsNodeFastBuffer,
    kNodeFastBufferSym,
    ArrayBufferViewIndexToCtor,
    CreatFakeCantBeSered,
    arrayBufferViewTypeToIndex,
} = require("./const");

const _ctx = require("./ctx");

////----

const WriteHeader = (a,kLatestVersion=15,ctx) => {
    a.push(SerializationTag.kVersion);
    a.push(kLatestVersion);
}

const WriteTag = (a,tag,ctx) => { a.push(tag)}

const WriteVarint = (a,v,ctx) => {
     if(_zigzag.is_smi_can_be_encded(v)){
        let next_byte;
        do {
           next_byte = (v & 0x7F) | 0x80 ;
           a.push(Number(next_byte)) ;
           v = v>>7;
        } while(v);
        a[a.length-1] = a[a.length-1] & 0x7F
        return(a)
     } else {
        v = BigInt(v);
        let next_byte;
        do {
           next_byte = (v & 0x7Fn) | 0x80n ;
           a.push(Number(next_byte)) ;
           v = v>>7n;
        } while(v);
        a[a.length-1] = a[a.length-1] & 0x7F
        return(a)
    }
}

const WriteZigZag = (a,v,ctx,encode=_zigzag.encd) => {
    v = encode(v);
    WriteVarint(a,v);
    return(a)
} 


const WriteDouble = (a,v,ctx,f64a) => {
    f64a = f64a?? new Float64Array(1);
    f64a[0] = v;
    let u8a = new Uint8Array(f64a.buffer);
    for(let i=0;i<8;++i) {
        a.push(u8a[i])
    }
    return(a)
}      

const  WriteOneByteString = (a,s,ctx) => {
    WriteVarint(a,s.length);
    for(let i=0;i<s.length;++i) {
        a.push(s.charCodeAt(i))
    }
    return(a)
}

const WriteTwoByteString = (a,s,ctx,mach) => {
    mach = mach?? (new _utf16.encd.mach.Mach());
    WriteVarint(a,s.length*2);
    for(let i =0;i<s.length;++i) {
        let cd = s.charCodeAt(i);
        let [fst,snd] = mach.input(cd);
        a.push(fst);
        a.push(snd)
    }
    return(a)
}


const WriteRawBytes = (a,byts,ctx) => {
   for(let i=0;i<byts.length;++i) {
       a.push(byts[i])
   }
   return(a) 
}

const WriteOddball = (a,o,ctx)=> {
  let tag = SerializationTag.kUndefined;
  switch (o) {
    case _u:
      tag = SerializationTag.kUndefined;
      break;
    case _f:
      tag = SerializationTag.kFalse;
      break;
    case _t:
      tag = SerializationTag.kTrue;
      break;
    case _n:
      tag = SerializationTag.kNull;
      break;
  }
  WriteTag(a,tag);
  return(a);  
}

const WriteSmi = (a,smi,ctx)=> {
  WriteTag(a,SerializationTag.kInt32,ctx);
  WriteZigZag(a,smi,ctx);
  return(a);  
}

const WriteHeapNumber = (a,number,ctx) => {
  WriteTag(a,SerializationTag.kDouble,ctx);
  WriteDouble(a,number,ctx);
  return(a);  
}


const WriteString = (a,s,ctx)=>{
     s | 0;                  // String::Flattern  
////-------------------------------------------------------------------
  if (_misc.IsOneByte(s)) {
      WriteTag(a,SerializationTag.kOneByteString,ctx);
      WriteOneByteString(a,s,ctx);
  } else {
      let byte_length   = s.length * 2;
      let head_byte_len = _misc.BytesNeededForVarint(byte_length);
      if((a.length + 1+ head_byte_len & 1)===0) {
          //no need padding   TAG | X0 X1 X2 |        ....data
      } else {
          //need padding      TAG | X0 X1 X2 X3|       ...data
          //              PAD TAG | X0 X1 X2 X3|
          //to make  len(PAD TAG | X0 X1 X2 X3|)  is even
          WriteTag(a,SerializationTag.kPadding,ctx);
      }
      WriteTag(a,SerializationTag.kTwoByteString,ctx);
      WriteTwoByteString(a,s,ctx);
  }
  return(a);  
}

const WriteJSDate = (a,dt,ctx) => {
    WriteTag(a,SerializationTag.kDate,ctx);
    WriteDouble(a,dt.getTime(),ctx);
    return(a);
}

const WriteJSRegExp = (a,rgx,ctx)=> {
     WriteTag(a,SerializationTag.kRegExp,ctx);
     WriteString(a,rgx.source,ctx);
     let ui32_flags = _rgx_flag.s2n(rgx.flags);
     WriteVarint(a,ui32_flags,ctx);
     return(a);
}

const WriteBigIntContents = (a,obi,ctx) => {
    let [sign,blen,bi] = _buf_bi._get_head(obi); 
    let encd_head      = (sign | (blen<<1));
    WriteVarint(a,encd_head,ctx);
    let bui64a         = new BigUint64Array(1);
    let u8a            = new Uint8Array(bui64a.buffer);
    while(bi) {
        bui64a[0] = bi & _buf_bi.MASK;
        a.push(u8a[0],u8a[1],u8a[2],u8a[3],u8a[4],u8a[5],u8a[6],u8a[7])
        bi = bi>>64n;
    }    
    return(a);
}

const WriteBigInt = (a,bi,ctx)=> {
    WriteTag(a,SerializationTag.kBigInt,ctx);
    WriteBigIntContents(a,bi,ctx);
    return(a);
}

const WriteByte    = (a,u8,ctx)     => { a.push(u8);                return(a);}
const WriteUint32  = (a,u32,ctx)    => { WriteVarint(a,u32,ctx)   ; return(a);}


const WriteJSPrimitiveWrapper = (a,v,ctx) => {
    if (_istis.is_truo(v)) {
         WriteTag(a,SerializationTag.kTrueObject,ctx);
         return(a);
    } else if (_istis.is_flso(v)) {
         WriteTag(a,SerializationTag.kFalseObject,ctx);
         return(a);
    } else if (_istis.is_numo(v)) {
         WriteTag(a,SerializationTag.kNumberObject,ctx);
         WriteDouble(a,Number(v),ctx);
         return(a);
    } else if (_istis.is_stro(v)) {
         WriteTag(a,SerializationTag.kStringObject,ctx);
         WriteString(a,String(v),ctx);
         return(a);
    } else if (_istis.is_bio(v)) {
         // this is impossible in js-layer
         WriteTag(a,SerializationTag.kBigIntObject,ctx);
         WriteBigIntContents(a,BigInt(v),ctx);
         return(a);
    } else {
         return(_u);   // this is a unmatch-flag 
    }
}


const WriteJSError = (a,e,ctx) => {

    WriteTag(a,SerializationTag.kError,ctx);
    let name = e.name; 
    switch(name) {
        case("EvalError" ):     {WriteVarint(a,ErrorTag.kEvalErrorPrototype,ctx     ); break;}
        case("RangeError"):     {WriteVarint(a,ErrorTag.kRangeErrorPrototype,ctx    ); break;}
        case("ReferenceError"): {WriteVarint(a,ErrorTag.kReferenceErrorPrototype,ctx); break;}
        case("SyntaxError"):    {WriteVarint(a,ErrorTag.kSyntaxErrorPrototype,ctx   ); break;}
        case("TypeError"):      {WriteVarint(a,ErrorTag.kTypeErrorPrototype,ctx     ); break;}
        case("URIError"):       {WriteVarint(a,ErrorTag.kUriErrorPrototype,ctx      ); break;}
        default: {
            //do nothing
        }
    }

    let message = String(e.message);
    WriteVarint(a,ErrorTag.kMessage,ctx);
    WriteString(a,message,ctx);
    
    let cause = e.cause;
    if(cause) {
        WriteVarint(a,ErrorTag.kCause,ctx);
        WriteObject(a,cause,ctx);
    } else {}

    let stack = String(e.stack);
    WriteVarint(a,ErrorTag.kStack,ctx);
    WriteString(a,stack,ctx);

    WriteVarint(a,ErrorTag.kEnd,ctx);
    return(a);
}


const WriteObject = (a,o,ctx) => {
  if (_typis.is_num(o)  && _misc.IsSmi(o)) {
      WriteSmi(a,o,ctx);
  } else if(o===_u) {
      WriteTag(a,SerializationTag.kUndefined,ctx);
  } else if(o===_n) {
      WriteTag(a,SerializationTag.kNull,ctx);
  } else if(o===_t) {
      WriteTag(a,SerializationTag.kTrue,ctx);
  } else if(o===_f) {
      WriteTag(a,SerializationTag.kFalse,ctx);
  } else if(_typis.is_num(o)) {
      WriteHeapNumber(a,o,ctx);
  } else if(_typis.is_bi(o))  {
       WriteBigInt(a,o,ctx);
  } else if(_typis.is_str(o)) {
      WriteString(a,o,ctx);
  } else {
      WriteJSReceiver(a,o,ctx);  //!id_map_.Find 
  }
  return(a);
}

const WriteJSSet = (a,st,ctx) => {
    WriteTag(a,SerializationTag.kBeginJSSet,ctx);
    let sz = 0;
    for(let e of st) {
        WriteObject(a,e,ctx);
        ++sz;
    }
    WriteTag(a,SerializationTag.kEndJSSet,ctx);
    WriteVarint(a,sz,ctx);
    return(a);
}

const WriteJSMap = (a,mp,ctx) => {
     WriteTag(a,SerializationTag.kBeginJSMap,ctx);
     let sz = mp.size * 2;
     for(let [k,v] of mp) {
         WriteObject(a,k,ctx);
         WriteObject(a,v,ctx);
     }
     WriteTag(a,SerializationTag.kEndJSMap,ctx);
     WriteVarint(a,sz,ctx);
     return(a);
}


//compatible with node delegate
const WriteHostObject = (a,o,ctx) => {
	let abvw_sub_type = arrayBufferViewTypeToIndex(o);  
    if(abvw_sub_type>-1) {
        WriteTag(a,SerializationTag.kHostObject,ctx);
        WriteUint32(a,   abvw_sub_type,      ctx);
        WriteUint32(a,   o.byteLength,       ctx);
        let u8a = new Uint8Array(o.buffer,o.byteOffset,o.byteLength);
        WriteRawBytes(a,u8a,ctx);
        return(a);
    } else {
    }
}

const WriteJSArrayBufferView = (a,o,ctx) =>  WriteHostObject(a,o,ctx);

const WriteJSArrayBuffer = (a,o,ctx) => {
     let is_resizable = _f;
     if(_istis.is_sab(o)) {
         is_resizable = Boolean(o.growable);     // compatible to nodejs version < 20
     } else {
         is_resizable = o.resizable 
     }
     let max_byte_length = (is_resizable)?o.maxByteLength:o.byteLength;
     let byte_length     = o.byteLength;
     if (is_resizable) {
         WriteTag(a,SerializationTag.kResizableArrayBuffer,ctx);
         WriteVarint(a,byte_length,ctx);
         WriteVarint(a,max_byte_length,ctx);
         WriteRawBytes(a,new Uint8Array(o),ctx);
     } else {
         WriteTag(a,SerializationTag.kArrayBuffer,ctx);
         WriteVarint(a,byte_length,ctx);
         WriteRawBytes(a,new Uint8Array(o),ctx);
     }
     return(a)
}

const WriteJSObject = (a,o,ctx) => {
  WriteTag(a,SerializationTag.kBeginJSObject,ctx);
  let properties_written = 0;                              // kv-pair length NOT entries length
  for(let k in o) {
      WriteObject(a,k,ctx);
      WriteObject(a,o[k],ctx);
      properties_written++;
  }
  WriteTag(a,SerializationTag.kEndJSObject,ctx);
  WriteVarint(a,properties_written,ctx);
  return(a)
}


const WriteJSArray = (a,o,ctx) => {
     let length                              = o.length;
     let   {is_packed_smi,is_packed_double}  = _misc.GetArrayPackedInfo(o); 
     if(is_packed_smi) {
         WriteTag(a,SerializationTag.kBeginDenseJSArray,ctx);
         WriteVarint(a,length,ctx);
         for(let i=0;i<o.length;++i) {
             WriteSmi(a,o[i],ctx);
         }
     } else if(is_packed_double) {
         WriteTag(a,SerializationTag.kBeginDenseJSArray,ctx);
         WriteVarint(a,length,ctx);
         if(length !==0) {
             for(let i=0;i<o.length;++i) {
                 WriteTag(a,SerializationTag.kDouble,ctx);
                 WriteDouble(a,o[i],ctx);
             }
         } else {}
     } else {
         WriteTag(a,SerializationTag.kBeginDenseJSArray,ctx);
         WriteVarint(a,length,ctx);
         for(let i=0;i<o.length;++i) {
             WriteObject(a,o[i],ctx);
         }
     }
     ////-------must use this slow method
     let ks = Object.keys(o);
     let properties_written = 0;
     for(let i=o.length;i<ks.length;++i) {
        let k = ks[i]; 
        WriteObject(a,k,ctx);
        WriteObject(a,o[k],ctx);
        properties_written++;
     } 
     WriteTag(a,SerializationTag.kEndDenseJSArray,ctx);
     WriteVarint(a,properties_written,ctx);
     WriteVarint(a,length,ctx);
     return(a);
}


const WriteJSReceiver = (a,o,ctx) => {
        if(is_untf(o)) {
            WriteOddball(a,o,ctx);
        } else if(_misc.IsSmi(o)) {   
            WriteSmi(a,o,ctx);
        } else if(_typis.is_num(o)) {
            WriteHeapNumber(a,o,ctx);
        } else if(_typis.is_str(o)) {
            WriteString(a,o,ctx);
        } else if(_typis.is_bi(o)) {
            WriteBigInt(a,o,ctx);
        } else if(_typis.is_sym(o)) {
            let phantom = CreatFakeCantBeSered("Symbol",o.description);
            WriteJSObject(a,phantom,ctx);            
        } else {
            let [already_exists,idx] = ctx.idmap.FindOrInsert(o);
            if (already_exists) {
                WriteTag(a,SerializationTag.kObjectReference,ctx);
                WriteVarint(a,idx,ctx);
            } else {
                if(_istis.is_ary(o)) {
                   WriteJSArray(a,o,ctx);
                } else if(_istis.is_st(o))  {
                    WriteJSSet(a,o,ctx);
                } else if(_istis.is_mp(o))  {
                    WriteJSMap(a,o,ctx);
                } else if(_istis.is_dt(o))  {
                    WriteJSDate(a,o,ctx); 
                } else if(_istis.is_rgx(o)) {
                    WriteJSRegExp(a,o,ctx);
                } else if(_istis.is_ab(o) || _istis.is_sab(o))  {
                    WriteJSArrayBuffer(a,o,ctx)
                } else if(o.buffer && _istis.is_ab(o.buffer)) {
                        //not correct ,but quick  
                        let r = WriteJSArrayBufferView(a,o,ctx);
                        if(r!==_u) {
                        } else {
                            WriteJSObject(a,o,ctx); 
                        }
                } else if(_typis.istof(o,Error)) {
                        WriteJSError(a,o,ctx); 
                } else {
                    let r = WriteJSPrimitiveWrapper(a,o,ctx);
                    if(r!==_u) {
                    } else {
                        if(
                            _typis.is_func_like(o) || 
                            is_prms(o)             ||
                            is_g(o)                ||
                            is_iter(o)
                        ) {
                            let phantom = CreatFakeCantBeSered(idx,String(o));
                            WriteJSObject(a,phantom,ctx);
                        } else {
                            WriteJSObject(a,o,ctx)
                        }
                    }
                }
            }
        }
        return(a)
}

const encd = (o,kLatestVersion=15) => {
    let a   = [];
    let ctx = _ctx.creat_wctx();
    WriteHeader(a,kLatestVersion);
    WriteJSReceiver(a,o,ctx);
    let u8a = new Uint8Array(a);
    return(u8a.buffer)
}

module.exports = {
    WriteHeader,
    WriteTag,
    WriteVarint,
    WriteZigZag,
    WriteDouble,
    WriteOneByteString,
    WriteTwoByteString,
    WriteRawBytes,
    WriteOddball,
    WriteSmi,
    WriteHeapNumber,
    WriteString,
    WriteJSDate,
    WriteJSRegExp,
    WriteBigIntContents,
    WriteBigInt,
    WriteByte,
    WriteUint32,
    WriteJSPrimitiveWrapper,
    WriteJSError,
    ////
    WriteObject,
    WriteJSSet,
    WriteJSMap,
    WriteHostObject,
    WriteJSArrayBufferView,
    WriteJSArrayBuffer,
    WriteJSObject,
    WriteJSArray,
    ////
    WriteJSReceiver,
    ////
    encd
}
