const path = require("path")



const get_parent = (p) => {
    let pp = path.parse(p).dir;
    return((pp===p)?null:pp)
}

const get_parent_after_resolve = (p) => {
    p = path.resolve(p);
    return(get_parent(p))
}

const creat_sib = (p,sib) => {
    if(path.isAbsolute(sib)) {
        return(sib)
    } else {
        let pp = get_parent(p);
        if(pp===null) {
            return(null)
        } else {
            return(path.join(pp,sib))
        }
    }
}

const creat_sib_after_resolve = (p,sib) => {
    p = path.resolve(p);
    return(creat_sib(p,sib))
}

const get_ance = (p,which=1) => {
    let an = get_parent(p);
    if(an===null) {
        return(null)
    } else {
        let c = 1
        while(an!==null) {
           if(c===which) {
               return(an)
           } else {
               c=c+1;
               an = get_parent(an)
           }
        }
        return(null)
    }
}

const get_ance_after_resolve =(p,which=1) => {
    p = path.resolve(p);
    return(get_ance(p,which))
}


const get_ances = (p)=> {
    let rslts = [];
    let an = get_parent(p);
    while(an!==null) {
        rslts.push(an);
        an = get_parent(an);
    }
    return(rslts)
}

const get_ances_after_resolve =(p) => {
    p = path.resolve(p);
    return(get_ances(p))
}


const is_hidden = (p) => path.parse(p).base[0]==='.';
const suffix_is = (p,suffix) => path.parse(p).ext === '.'+suffix;
const name_is   = (p,name) => path.parse(p).name === name;


const is_abs    = (p) => path.isAbsolute (p);
const is_root   = (p) => path.resolve(p) === '/';


const _get_tail_char  = (p) => p[p.length-1];
const is_nv_file_path = (p) => p[p.length-1] !== '/';
const is_nv_dir_path  = (p) => p[p.length-1] === '/';


const _is_child_of = (cp,p) => get_parent(cp)===p;

const is_child_of = (cp,p) => {
   p  = path.resolve(p);
   return(get_parent(cp)===p) 
}


const to_nvpath = (p)=> {
    p  = path.resolve(p);
    if(p==='/') {
        return(p);
    } else {
        try {
            const fs = require("fs");
            if(fs.lstatSync(p).isDirectory()) {
                return(p+'/')
            } else {}
            return(p)
        } catch(err) {
            return(p)
        }
    }
}


const topl = (p,enable_nv=false) => {
    if(enable_nv) { p = to_nvpath(p)} else { p  = path.resolve(p);}
    pl = p.split('/');
    return(pl)
}

const _is_des_of = (des,p) => {
    let an = get_parent(des);
    while(an!==null) {
        if(an === p){
            return(true)
        } else {
            an = get_parent(an);
        }
    }
    return(false)
}


const is_des_of = (des,p) => {
    des = path.resolve(des);
    p  = path.resolve(p);
    return(_is_des_of(des,p)) 
}


////
const unparse  = (d) => path.join(d.dir,d.base);

const _rplc_suffix = (d,new_suffix) => {
    if(d.ext !== '') {
        d.ext = '.'+new_suffix;
        d.base = d.name + d.ext;
    } else {}
    return(d)
}

////
const rplc_suffix = (p,new_suffix) => {
     p = path.resolve(p);
     let d = path.parse(p);
     d = _rplc_suffix(d,new_suffix);
     return(unparse(d))
}

const _rplc_name = (d,new_name) => {
    if(d.name !== '') {
        d.name = new_name;
        d.base = d.name + d.ext;
    } else {}
    return(d)
}


const rplc_name = (p,new_name) => {
     p = path.resolve(p);
     let d = path.parse(p);
     d = _rplc_name(d,new_name);
     return(unparse(d))
}

const _has_suffix = (d) => d.ext!=='';

const has_suffix = (p) => {
    p = path.resolve(p);
    let d = path.parse(p);
    return(_has_suffix(d))
}

const rplc_dir = (p,which=0,ndir,enable_nv=false) => {
    p = path.resolve(p);
    let pl = topl(p,enable_nv);
    let lst = pl[pl.length-1];
    let start;
    if(lst === '') {
        start = pl.length-1;
    } else {
        start = pl.length-2;
    }
    let idx = start-which;
    if(idx>=1) {
        pl[idx]=ndir
    } else {}
    return(pl.join('/'))
}


const relative = (p0,p1)=> {
    let rel = path.relative(p0,p1);
    if(rel[0]==='.') {
        return(rel)
    } else {
        return("./"+rel)
    }
}

const _RGX_BAD = /[\$\-'"` \t\v\f\n\r]+/g


const is_good_path = (p)=> !_RGX_BAD.test(p);


const depth = (p) => {
   let ances = get_ances_after_resolve(p); 
   return(ances.length) 
}

const get_base = (p)=>path.parse(path.resolve(p)).base;


////

class _Parsed {
   is_abs= false
   pl    = []
   fname = null 
   get is_dir() {return(this.fname===null)}
   get list() {
       let pl = this.pl.slice(0);
       if(this.is_dir) {
       } else {
           pl.push(this.fname)
       }
       return({is_abs:this.is_abs,pl})
   }
}

function parse_nvpath(s="./",sp="/",dot=".") {
    if(s==="") {s="./"} 
    let arr = Array.from(s)
    let p = new _Parsed();
    p.is_abs = arr[0]===sp;
    ////
    let state;
    let scache = "";
    if(p.is_abs) {
        state = 0;
    } else if (arr[0]===dot) {
        state = 2;
        scache = arr[0];
    } else {
        state = 1;
        scache = arr[0];
    }
    arr.shift();
    ////
    let c = 0;
    let pl = []
    while(c<arr.length) {
        let ch = arr[c]
        if(state ===0) {  // prev is sp
            if(ch===sp) {
                //donothing 多个sp 合并
            } else if(ch === dot) {
                state = 2
                scache = dot
            } else {
                scache = ch;
                state = 1;
            }
        } else if(state === 1){
            if(ch===sp) {
                pl.push(scache);
                scache = ""
                state = 0
            } else {
                scache = scache +ch
            }
        } else {
            if(ch===sp) {
                let popc = state -2;
                for(let i=0;i<popc;i++) {
                    pl.pop();
                }
                scache = "";
                state = 0;
            } else if(ch === dot) {
                 state = state +1
            } else {
                 scache = scache +ch;
                 state = 1;
            }
        }
        c = c+1
    }
    p.pl = pl;
    if(scache !== "" && state === 1) {
        p.fname = scache;
        scache  = ""
    } else if (state ===0) {
        //ignore  /
    } else {
        //ignore   ...
    }
    return(p)
}

function unparse_nvpath(p,sp="/") {
    let s = p.pl.join(sp);
    if(p.is_dir) {s=s+sp} else {
        if(s!=="") {
            s=s+sp+p.fname
        } else {
            s=p.fname
        }
    }
    if(p.is_abs) {s=sp+s} else {}
    return(s)
}


module.exports = {
   ////
   curr:  ()=>process.cwd(),
   //// 
   get_parent,
   get_parent_after_resolve,
   get_ance,
   get_ance_after_resolve, 
   get_ances,
   get_ances_after_resolve, 
   creat_sib,
   creat_sib_after_resolve, 
   ////
   _is_child_of,
   is_child_of,
   _is_des_of,
   is_des_of,
   ////
   is_hidden,
   is_abs, 
   is_root,
   ////
   _get_tail_char,
   is_nv_file_path,
   is_nv_dir_path,
   to_nvpath, 
   ////
   topl,
   ////
   suffix_is,
   name_is,
   //// 
   unparse,
   _rplc_suffix, 
   rplc_suffix,
   _rplc_name,
   rplc_name,
   ////
   _has_suffix,
   has_suffix, 
   ////
   rplc_dir,
   ////
   relative,
   is_good_path, 
   depth,
   get_base,
   ////
   parse_nvpath,
   unparse_nvpath, 
}

Object.defineProperty(module.exports,"pkg_",{get:function(){return(__dirname)}})

