const {_u,_n,_t,_f} = require("nv-facutil-untf")

const _path  = require("path");
const _fs    = require("fs");
const pbsc   = require("nv-path-basic");
const CONSTS = require("nv-file-const");

const _readlink_without_resolve = (p) => pbsc.creat_sib_after_resolve(p,_fs.readlinkSync(p));

const _readlink_r = (p,resolve=_f,do_init_check=_f) => {
      p           = resolve?_path.resolve(p):p;
      if(do_init_check) {
	  if(_fs.existsSync(p)) {
	      let rslt   = _fs.lstatSync(p);
	      let cond   = rslt.isSymbolicLink();
	      if(cond) {
	           p = _readlink_without_resolve(p);
	      } else {
	          return(p);
	      }
	  }  else {
	      return(_n)
	  }
      } else {
      }
      ///-------------------------------------------
      while(_t) {
	 if(_fs.existsSync(p)) {
		 let rslt   = _fs.lstatSync(p);  
		 let cond   = rslt.isSymbolicLink();
		 if(cond) {
		     p = _readlink_without_resolve(p);
		 } else {
		     return(p);
		 }
	 } else {
             return(_n)  // invalide
	 }
      }
}

class Permission {
    owner_can_read=_f;
    owner_can_write=_f;
    owner_can_exec=_f;
    group_can_read=_f;
    group_can_write=_f;
    group_can_exec=_f;
    other_can_read=_f;
    other_can_write=_f;
    other_can_exec=_f
}

const _permission_with_stat = (stat) => {
    let mode = stat.mode;
    mode = mode & 0b111111111;
    let d = new Permission();
    for(let k in CONSTS.PNAMES) {
        d[k] = Boolean(mode & CONSTS.pname_to_num(k) )
    }
    return(d)
}

const stat = (p,resolve=_f) => {
    p       = resolve?_path.resolve(p):p
    let r   = {type:_u,linkto:_u};
    let d   = _path.parse(p);
    Object.assign(r,d);
    r.path  = p;
    if(_fs.existsSync(p)) {
        let data = _fs.lstatSync(p);
	r["#stat"] = data;
	if(data.isFile()) {
            r.type = 'file';
	} else if(data.isDirectory()) {
            r.type = 'dir'
	} else if(data.isSocket()) {
            r.type = 'sock' 
	} else if(data.isSymbolicLink()) {
            r.type = 'slink';
	    r.linkto = _readlink_r(p);
	} else if(data.isBlockDevice()) {
	    r.type = "blk_dev"
	} else if(data.isCharacterDevice()) {
	    r.type = "char_dev"
	} else if(data.isFIFO()) {
	    r.type = "fifo";
	} else {
	    r.type = "unknown"
	}
	r["#permission"] = _permission_with_stat(data)
    } else {
	r.type = 'noexist';
    }
    return(r)
}


////
const _get_children_with_stat = (p,stat) => {
    let cond = stat.isDirectory();
    if(cond) {
        let arr = _fs.readdirSync(p);
        arr = arr.map(r=>_path.join(p,r));
        return(arr)
    } else {
        return([])
    }
}

const get_children = (p) => {
     p = _path.resolve(p);
     let cond = _fs.existsSync(p);
     if(cond) {
         let stat = _fs.lstatSync(p);
         return(_get_children_with_stat(p,stat))
     } else {
         return([])
     }
}

const _is_leaf_with_stat =(p,stat) => {
    let cond = stat.isDirectory();
    if(cond) {
        let arr = _fs.readdirSync(p);
        return(arr.length===0)
    } else {
        return(_t)
    }
}

const is_leaf = (p) => {
     p = _path.resolve(p);
     let cond = _fs.existsSync(p);
     if(cond) {
         let stat = _fs.lstatSync(p);
         return(_is_leaf_with_stat(p,stat))
     } else {
         return(_t)
     }
}


////

module.exports = {
    CONSTS,
    ////
    _readlink_without_resolve,
    _readlink_r,
    ////
    Permission,
    _permission_with_stat,
    ////
    stat,
    ////
    _get_children_with_stat,
    get_children,
    ////
    _is_leaf_with_stat,
    is_leaf,
    ////
}


