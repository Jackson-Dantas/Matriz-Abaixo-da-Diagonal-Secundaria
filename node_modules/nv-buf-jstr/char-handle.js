const {cd2ch} = require("./cmmn");

const {is_high_surrogate} = require("./decd-def");





const _next = (s,len,offset)=> {
     let ccd = s[offset].charCodeAt(0);
     if(is_high_surrogate(ccd)) {
         return([s.codePointAt(offset),offset,offset+2])
     } else {
         return([ccd,offset,offset+1])
     }   
}

const _fst = (s,len) => {
    if(len === 0) {
        return([-1,-1,0])
    } else {
        return(_next(s,len,0))
    }
}



const _while = (s,handle=(cd,ci,offset)) => {
     let len = s.length;
     let ci  = 0;
     let [cd,curr_offset,next_offset]   = _fst(s,len);
     handle(cd,ci,curr_offset);
     ++ci;
     curr_offset = next_offset;
     while(curr_offset < len) {
         [cd,curr_offset,next_offset] = _next(s,len,curr_offset);
         handle(cd,ci,curr_offset);
         ++ci;
         curr_offset = next_offset;
     }
}

/*

> x.max_cmmn_psfix("abacab")
ci    :[ 0, 0, 1, 0, 1, 2 ]
offset:[]
>
> x.max_cmmn_psfix("abab")
ci:    [ 0, 0, 1, 2 ]
offset:[]
>


*/

const max_cmmn_psfix = (s) => {
     let len             = s.length;

     let mxary           = Array.from({length:len}).map(r=>[-1,-1]);
     let ofary           = Array.from({length:len}).map(r=>-1);
     let cdary           = Array.from({length:len}).map(r=>-1); 
     let szary           = Array.from({length:len}).map(r=>-1);

     let ci  = 0;
     let [cd,curr_offset,next_offset]   = _fst(s,len);
     //----------------------
     //----------------------
     mxary[ci][0] = 0;
     mxary[ci][1] = 0;
     cdary[ci]    = cd;
     ofary[ci]    = curr_offset;
     szary[ci]    = (next_offset - curr_offset);
     ++ci;
     curr_offset = next_offset;
     /////
     while(curr_offset < len) {
         [cd,curr_offset,next_offset] = _next(s,len,curr_offset);
         //-------------------------
         let prev_mx = mxary[ci-1];             //                   cmpcd  
         let cmpcd   = cdary[prev_mx[0]];      // [0 - prev_mx-1]#0, prev_mx   [.....]#1 cd
                                               //    #0 same-as #1
         /*
            abacab
            001012
                    input   cond                     tail-idx  
            a       <init>  false                    mx(a:i0) =              0           
            ab      b       s[mx(a:i0)] !== input    mx(b:i1) =              0
            aba     a       s[mx(b:i1)] === input    mx(a:i2) = mx(b:i1)+1   1 
            abac    c       s[mx(a:i2)] !== input    mx(c:i3) =              0     
            abaca   a       s[mx(c:i3)] === input    mx(a:i4) = mx(c:i3)+1   1
            abacab  b       s[mx(a:i4)] === input    mx(b:i5) = mx(a:i4)+1   2
          */
         if(cd === cmpcd) {
             mxary[ci][0] = prev_mx[0] + 1;
             mxary[ci][1] = szary[prev_mx[0]];
         } else {
             mxary[ci][0] = 0;
             mxary[ci][1] = 0;
         }
         //------------------------
         cdary[ci] = cd;
         ofary[ci]   = curr_offset;
         szary[ci]   = szary[ci-1] + (next_offset - curr_offset);
         ++ci;
         curr_offset = next_offset;
     }     
     return({
         mx     : mxary,
         cd     : cdary,
         of     : ofary,
         sz     : szary
     }) 
}


const mvto = (cmmn_prefix,sci,sof,eci,eof) => {
    let of = sof + eof - cmmn_prefix.mx[eci-sci-1][1]; 
    return(of)
}

module.exports = {
   _fst,   // (s,len)        => [code,curr_offset,next_offset]
   _next,  //  (s,len,offset)=> [code,curr_offset,next_offset]
   _while,
   max_cmmn_psfix, 
   mvto,
}

